/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/helpers/util.js":
/*!*****************************!*\
  !*** ./src/helpers/util.js ***!
  \*****************************/
/***/ (() => {

eval("/* global monthList, months */\n\nvar Util = function () {\n  //Formattering\n  var format = function () {\n    var formatDateForBackend = function (date) {\n      if (date === \"\") {\n        return \"\";\n      }\n      var fDate = new Date(date);\n      return fDate.getFullYear() + \"-\" + (fDate.getMonth() + 1) + \"-\" + fDate.getDate() + \" \" + fDate.getHours() + \":\" + fDate.getMinutes() + \":\" + fDate.getSeconds() + \"\";\n    };\n    var getDateFormat = function (from, to) {\n      let ret = [];\n      let fromDate = new Date(from.replace(\" \", \"T\"));\n      let toDate = new Date(to.replace(\" \", \"T\"));\n      //\t\t\tlet fromDate = new Date(from);\n      //\t\t\tlet toDate = new Date(to);\n\n      if (fromDate.getDate() === toDate.getDate()) {\n        ret.push(fromDate.getDate() + \". \");\n        let month = monthList[fromDate.getMonth()];\n        ret.push(months[month]);\n        return ret;\n      } else {\n        ret.push(fromDate.getDate() + \".-\" + toDate.getDate() + \".\");\n        let month = monthList[fromDate.getMonth()];\n        ret.push(months[month]);\n        return ret;\n      }\n    };\n    var getTimeFormat = function (from, to) {\n      let fromDate = new Date(from.replace(\" \", \"T\"));\n      let toDate = new Date(to.replace(\" \", \"T\"));\n      //\t\t\tlet fromDate = new Date(from);\n      //\t\t\tlet toDate = new Date(to);\n      let ret;\n      ret = (fromDate.getHours() < 10 ? '0' + fromDate.getHours() : fromDate.getHours()) + \":\" + (fromDate.getMinutes() < 10 ? '0' + fromDate.getMinutes() : fromDate.getMinutes()) + \" - \" + (toDate.getHours() < 10 ? '0' + toDate.getHours() : toDate.getHours()) + \":\" + (toDate.getMinutes() < 10 ? '0' + toDate.getMinutes() : toDate.getMinutes());\n      return ret;\n    };\n    return {\n      FormatDateForBackend: formatDateForBackend,\n      GetDateFormat: getDateFormat,\n      GetTimeFormat: getTimeFormat\n    };\n  }();\n  return {\n    Format: format\n  };\n}();\n$(document).ready(function () {\n  $(\"input[type=radio][name=select_template]\").change(function () {\n    var template = $(this).val();\n    var oArgs = {\n      menuaction: 'bookingfrontend.preferences.set'\n    };\n    var requestUrl = phpGWLink('bookingfrontend/', oArgs, true);\n    $.ajax({\n      type: 'POST',\n      dataType: 'json',\n      data: {\n        template_set: template\n      },\n      url: requestUrl,\n      success: function (data) {\n        //\t\tconsole.log(data);\n        location.reload(true);\n      }\n    });\n  });\n  $(\"input[type=radio][name=select_language]\").change(function () {\n    var lang = $(this).val();\n    var oArgs = {\n      menuaction: 'bookingfrontend.preferences.set'\n    };\n    var requestUrl = phpGWLink('bookingfrontend/', oArgs, true);\n    $.ajax({\n      type: 'POST',\n      dataType: 'json',\n      data: {\n        lang: lang\n      },\n      url: requestUrl,\n      success: function (data) {\n        location.reload(true);\n      }\n    });\n  });\n});\n\n//# sourceURL=webpack://bookingfrontend_2/./src/helpers/util.js?");

/***/ }),

/***/ "./src/pages/search.js":
/*!*****************************!*\
  !*** ./src/pages/search.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/util */ \"./src/helpers/util.js\");\n/* harmony import */ var _helpers_util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_helpers_util__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// Easier way of getting old value from KO on change\nko.subscribable.fn.subscribeChanged = function (callback) {\n  let previousValue;\n  this.subscribe(function (_previousValue) {\n    previousValue = _previousValue;\n  }, undefined, 'beforeChange');\n  this.subscribe(function (latestValue) {\n    callback(latestValue, previousValue);\n  });\n};\nclass OrganizationSearch {\n  data = {\n    activities: ko.observableArray([]),\n    selected_activities: ko.observableArray([]),\n    organizations: ko.observableArray([]),\n    selected_organizations: ko.observableArray([]),\n    text: ko.observable(\"\")\n  };\n  constructor() {\n    const organizationEl = document.getElementById(\"search-organization\");\n    ko.cleanNode(organizationEl);\n    ko.applyBindings(this.data, organizationEl);\n    this.data.text.subscribe(text => {\n      this.search();\n    });\n    this.data.selected_activities.subscribe(activities => {\n      this.search();\n    });\n  }\n  reset() {\n    $('#search-organization-activities').val([]).trigger('change');\n    this.data.text(\"\");\n  }\n  search() {\n    let organizations = [];\n    const el = emptySearch();\n    if (this.data.text() !== \"\" || this.data.selected_organizations().length > 0 || this.data.selected_activities().length > 0) {\n      const re = new RegExp(this.data.text(), 'i');\n      organizations = this.data.organizations().filter(o => o.name.match(re));\n      if (this.data.selected_organizations().length > 0) {\n        organizations = organizations.filter(o => this.data.selected_organizations().some(ko => ko.id === o.id));\n      }\n      if (this.data.selected_activities().length > 0) {\n        let ids = [];\n        for (const activity of this.data.selected_activities()) {\n          ids.push(...getAllSubRowsIds(this.data.activities(), activity.id));\n        }\n        // Unique\n        ids = [...new Set(ids)];\n        organizations = organizations.filter(o => ids.some(id => id === o.activity_id));\n      }\n      this.addInfoCards(el, organizations.slice(0, 10), organizations.length);\n    } else {\n      fillSearchCount(null);\n    }\n    createJsSlidedowns();\n  }\n  addInfoCards = (el, organizations, count) => {\n    const append = [];\n    for (const organization of organizations) {\n      append.push(`\n    <div class=\"col-12 mb-4\">\n      <div class=\"js-slidedown slidedown\">\n        <button class=\"js-slidedown-toggler slidedown__toggler\" type=\"button\" aria-expanded=\"false\">\n          <span>${organization.name}</span>\n          <span class=\"slidedown__toggler__info\">\n          ${joinWithDot([organization.email, organization.street])}\n          </span>\n        </button>\n        <div class=\"js-slidedown-content slidedown__content\">\n          <p>\n            ${organization.description}\n            <ul>\n                <li>Hjemmeside: ${organization.homepage}</li>\n                <li>Tlf: ${organization.phone}</li>\n                <li>E-post: ${organization.email}</li>\n                <li>Adresse: ${organization.street}</li>\n                <li>Postnr: ${organization.zip_code}</li>\n                <li>Poststed: ${organization.city}</li>\n                <li>Distrikt: ${organization.district}</li>\n                <li><a href=\"${phpGWLink('bookingfrontend/', {\n        menuaction: 'bookingfrontend.uiorganization.show',\n        id: organization.id\n      }, false)}\">Mer info</a></li>\n            </ul>\n          </p> \n        </div>\n      </div>\n    </div>\n`);\n    }\n    el.append(append.join(\"\"));\n    fillSearchCount(organizations, count);\n  };\n}\nclass BookingSearch {\n  data = {\n    towns_data: ko.observableArray([]),\n    towns: ko.observableArray([]),\n    selected_town: ko.observable(),\n    buildings: ko.observableArray([]),\n    selected_buildings: ko.observableArray([]),\n    building_resources: ko.observableArray([]),\n    activities: ko.observableArray([]),\n    selected_activities: ko.observableArray([]),\n    resource_activities: ko.observableArray([]),\n    resource_categories: ko.observableArray([]),\n    selected_resource_categories: ko.observableArray([]),\n    resource_category_activity: ko.observableArray([]),\n    resources: ko.observableArray([]),\n    selected_resources: ko.observableArray([]),\n    facilities: ko.observableArray([]),\n    selected_facilities: ko.observableArray([]),\n    resource_facilities: ko.observableArray([]),\n    text: ko.observable(\"\"),\n    date: ko.observable(getSearchDateString(new Date())),\n    show_only_available: ko.observable(false),\n    result: ko.observableArray([]),\n    result_all: ko.observableArray([]),\n    available_resources: ko.observableArray([]),\n    taken_allocations: ko.observableArray([]),\n    seasons: ko.observableArray([]),\n    resources_with_available_time: ko.observableArray([]),\n    easy_booking_available_ids: ko.observableArray([])\n  };\n  activity_cache = {};\n  allocation_cache = {};\n  easy_booking_available_cache = {};\n  easy_booking_not_available_cache = {};\n  constructor() {\n    const bookingEl = document.getElementById(\"search-booking\");\n    ko.cleanNode(bookingEl);\n    ko.applyBindings(this.data, bookingEl);\n    this.updateBuildings(null);\n    this.data.text.subscribe(_ => this.searchFetch());\n    this.data.selected_buildings.subscribe(_ => this.searchFetch());\n    this.data.selected_resource_categories.subscribe(_ => this.searchFetch());\n    this.data.selected_facilities.subscribe(_ => this.searchFetch());\n    this.data.selected_activities.subscribe(_ => this.searchFetch());\n    this.data.show_only_available.subscribe(show => {\n      if (!show) this.data.resources_with_available_time([]);\n      this.searchFetch();\n    });\n    this.data.towns.subscribe(_ => this.updateBuildings(null));\n    this.data.date.subscribe(date => {\n      if (date === \"\") {\n        this.data.date(getSearchDateString(new Date()));\n        return;\n      }\n      this.searchFetch();\n    });\n    this.data.selected_town.subscribe(town => {\n      this.updateBuildings(town);\n      this.searchFetch();\n    });\n    this.data.towns_data.subscribe(towns => {\n      this.data.towns([...new Set(towns.map(item => item.name))].sort((a, b) => a.localeCompare(b, \"no\")).map(name => ({\n        name: htmlDecode(name),\n        id: towns.find(i => i.name === name).id\n      })));\n    });\n    this.data.activities.subscribe(activities => {\n      for (const activity of activities) {\n        this.activity_cache[activity.id] = getAllSubRowsIds(activities, activity.id);\n      }\n    });\n    this.data.result_all.subscribeChanged((result, old) => {\n      // Only download new available resources if old data is different from new\n      if (arraysAreEqual(result.map(r => r.id).sort(), old.map(r => r.id).sort())) return;\n      if (this.data.show_only_available()) this.fetchAvailableResources();\n    });\n  }\n  fetchEasyBooking(finished) {\n    const start_date = `${this.data.date()}`;\n    const end_date = `${this.data.date()}`;\n    if (!(start_date in this.easy_booking_available_cache)) {\n      this.easy_booking_available_cache[start_date] = [];\n      this.easy_booking_not_available_cache[start_date] = [];\n    }\n    const resource_ids = [...new Set(this.data.result_all().filter(r => !this.easy_booking_not_available_cache[start_date].includes(r.id) && !this.easy_booking_available_cache[start_date].includes(r.id)).map(r => r.id))];\n    if (resource_ids.length === 0) {\n      finished();\n      return;\n    }\n    const url = phpGWLink('bookingfrontend/', {\n      menuaction: 'bookingfrontend.uibooking.get_freetime_limit',\n      start_date,\n      end_date,\n      resource_ids: resource_ids.join(\",\"),\n      length: -1\n    }, true);\n    $.ajax({\n      url,\n      success: response => {\n        // console.log(\"Res\", response);\n        this.populate_easy_booking_available_cache(response, start_date, resource_ids);\n        finished();\n      },\n      error: error => {\n        console.log(error);\n        finished();\n      }\n    });\n  }\n  fetchAvailableResources() {\n    let fetched_easy_booking = false;\n    let fetched_available_resource = false;\n    const from_date = `${this.data.date()} 00:00:00`;\n    const to_date = `${this.data.date()} 23:59:59`;\n    const onSuccess = () => {\n      if (fetched_easy_booking && fetched_available_resource) {\n        this.data.available_resources([]);\n        this.data.taken_allocations(this.data.result_all().filter(r => r.simple_booking !== 1).map(r => this.allocation_cache[from_date].allocations[r.id]).flat());\n        this.data.seasons(this.data.result_all().filter(r => r.simple_booking !== 1).map(r => this.allocation_cache[from_date].seasons[r.id]).flat());\n        this.calculateAvailableResources();\n        this.search();\n        // console.log(\"Easy Cache\", this.easy_booking_available_cache)\n      }\n    };\n    this.fetchEasyBooking(() => {\n      fetched_easy_booking = true;\n      onSuccess();\n    });\n    if (!(from_date in this.allocation_cache)) {\n      this.allocation_cache[from_date] = {};\n      this.allocation_cache[from_date].allocations = {};\n      this.allocation_cache[from_date].seasons = {};\n    }\n    const resource_ids = [...new Set(this.data.result_all().filter(r => r.simple_booking !== 1).filter(r => !(r.id in this.allocation_cache[from_date].allocations)).map(r => r.id))];\n    if (resource_ids.length === 0) {\n      fetched_available_resource = true;\n      onSuccess();\n      return;\n    }\n    const url = phpGWLink('bookingfrontend/', {\n      menuaction: 'bookingfrontend.uisearch.search_available_resources',\n      from_date,\n      to_date,\n      resource_ids: resource_ids.join(\",\"),\n      length: -1\n    }, true);\n    $.ajax({\n      url,\n      success: response => {\n        // console.log(\"Res\", response);\n        this.populate_allocation_cache(response, from_date, resource_ids);\n        fetched_available_resource = true;\n        onSuccess();\n      },\n      error: error => {\n        console.log(error);\n      }\n    });\n  }\n  populate_allocation_cache = (response, from_date, resource_ids) => {\n    const cache = this.allocation_cache[from_date];\n    resource_ids.map(id => {\n      if (!(id in cache.allocations)) cache.allocations[id] = [];\n      if (!(id in cache.seasons)) cache.seasons[id] = [];\n    });\n    response.allocations.map(allocation => {\n      cache.allocations[allocation.resource_id].push(allocation);\n    });\n    response.seasons.map(season => {\n      cache.seasons[season.resource_id].push(season);\n    });\n  };\n  populate_easy_booking_available_cache = (response, start_date, resource_ids) => {\n    const cache = this.easy_booking_available_cache[start_date];\n    Object.keys(response).map(resource_id => {\n      response[resource_id].map(resource => {\n        if (!resource.overlap) {\n          cache.push(resource.applicationLink.resource_id);\n        }\n      });\n    });\n    this.easy_booking_available_cache[start_date] = [...new Set(cache)];\n    this.easy_booking_not_available_cache[start_date] = [...new Set(resource_ids.filter(id => !this.easy_booking_available_cache[start_date].includes(id)))];\n  };\n  reset() {\n    this.data.selected_town(null);\n    $('#search-booking-activities').val([]).trigger('change');\n    $('#search-booking-building').val([]).trigger('change');\n    $('#search-booking-resource_categories').val([]).trigger('change');\n    $('#search-booking-facilities').val([]).trigger('change');\n    this.data.text(\"\");\n    this.data.date(getSearchDateString(new Date()));\n  }\n  searchFetch() {\n    if (this.data.show_only_available()) this.fetchAvailableResources();else this.search();\n  }\n  search() {\n    let resources = [];\n    let hasSearch = false;\n    if (this.data.selected_town() !== undefined || this.data.selected_buildings().length > 0 || this.data.selected_facilities().length > 0 || this.data.selected_activities().length > 0 || this.data.selected_resource_categories().length > 0) {\n      resources = this.data.resources();\n      if (this.data.selected_town() !== undefined) resources = resources.filter(resource => this.data.building_resources().some(br => this.data.buildings().some(b => b.id === br.building_id && resource.id === br.resource_id)));\n      if (this.data.selected_buildings().length > 0) {\n        resources = resources.filter(resource => this.data.building_resources().some(br => this.data.selected_buildings().some(sb => sb.id === br.building_id && resource.id === br.resource_id)));\n      }\n      if (this.data.selected_facilities().length > 0) {\n        resources = resources.filter(resource => this.data.selected_facilities().map(f => f.id).every(id => this.data.resource_facilities().some(rf => rf.resource_id === resource.id && rf.facility_id === id)));\n      }\n      if (this.data.selected_activities().length > 0) {\n        resources = resources.filter(resource => this.data.selected_activities().map(f => f.id).every(id => this.data.resource_activities().some(ra => this.activity_cache[id].includes(ra.activity_id) && resource.id === ra.resource_id)));\n      }\n      if (this.data.selected_resource_categories().length > 0) {\n        resources = resources.filter(res => this.data.selected_resource_categories().some(cat => cat.id === res.rescategory_id));\n      }\n      hasSearch = true;\n    }\n    if (this.data.text() !== \"\") {\n      if (!hasSearch) resources = this.data.resources();\n      const re = new RegExp(this.data.text(), 'i');\n      let buildings_resources = [];\n      let activity_resources = [];\n      // Find all buildings matching so we can filter on later\n      if (this.data.selected_buildings().length === 0) {\n        const buildings = this.data.buildings().filter(building => building.name.match(re));\n        buildings_resources = this.getResourcesFromBuildings(buildings);\n      }\n      if (this.data.selected_activities().length === 0) {\n        const matchingActivities = this.data.activities().filter(activity => activity.name.match(re));\n        const activitySets = matchingActivities.map(activity => this.activity_cache[activity.id]);\n        const resourceActivities = this.data.resource_activities();\n        const resourceIdsSet = new Set(activitySets.flatMap(actIds => actIds.flatMap(a => resourceActivities.filter(ref => ref.activity_id === a))).map(act => act.resource_id));\n        activity_resources = this.data.resources().filter(resource => resourceIdsSet.has(resource.id));\n      }\n      resources = [...resources.filter(resource => resource.name.match(re) || buildings_resources.some(r => r.id === resource.id)), ...activity_resources];\n      hasSearch = true;\n    }\n    const el = emptySearch();\n    if (hasSearch) {\n      // Remove duplicates\n      resources = resources.reduce((accumulator, current) => {\n        if (accumulator.findIndex(item => item.id === current.id) === -1) {\n          accumulator.push(current);\n        }\n        return accumulator;\n      }, []);\n      this.data.result_all(resources);\n      if (this.data.show_only_available()) resources = resources.filter(r => this.data.resources_with_available_time().includes(r.id));\n      this.addInfoCards(el, resources.sort((a, b) => a.name.localeCompare(b.name)));\n    } else {\n      fillSearchCount(null);\n      this.addInfoCards(el, []);\n    }\n    createJsSlidedowns();\n  }\n  calculateAvailableResources = () => {\n    const timeToNumber = time => {\n      const [hour, min, sec] = time.split(\":\");\n      return +sec + +min * 60 + +hour * 3600;\n    };\n    const numberToTime = num => {\n      const date = new Date(num * 1000);\n      return getFullTimeString(date);\n    };\n    const getApiDate = dateString => {\n      const [day, month, year] = this.data.date().split(\".\");\n      return new Date(`${year}-${month}-${day}`);\n    };\n    const isSameDate = (fromDateString, toDateString) => {\n      const from = new Date(fromDateString.split(\" \")[0]);\n      const to = new Date(toDateString.split(\" \")[0]);\n      const same = from.getDate() === to.getDate() && from.getMonth() === to.getMonth() && from.getFullYear() === to.getFullYear();\n      return same;\n    };\n    const allocationFillsAllowed = (allocations, allowed) => {\n      allocations.sort((a, b) => a[0] - b[0]);\n      const mergedAllocations = [allocations[0]];\n      for (let i = 1; i < allocations.length; i++) {\n        const lastMerged = mergedAllocations[mergedAllocations.length - 1];\n        if (allocations[i][0] <= lastMerged[1]) {\n          lastMerged[1] = Math.max(lastMerged[1], allocations[i][1]);\n        } else {\n          mergedAllocations.push(allocations[i]);\n        }\n      }\n      const totalAllocatedSeconds = mergedAllocations.reduce((sum, allocation) => {\n        return sum + (allocation[1] - allocation[0]);\n      }, 0);\n      const totalAllowedSeconds = allowed.reduce((sum, range) => {\n        return sum + (range[1] - range[0]);\n      }, 0);\n      return totalAllocatedSeconds >= totalAllowedSeconds;\n    };\n    const date = getApiDate(this.data.date());\n    const wday = date.getDay();\n    const resource_allocation = this.data.taken_allocations().reduce((acc, cur) => {\n      acc[cur.resource_id] = acc[cur.resource_id] || [];\n      acc[cur.resource_id].push([timeToNumber(cur.from_.split(\" \")[1]), !isSameDate(cur.from_, cur.to_) ? 86400 : timeToNumber(cur.to_.split(\" \")[1])]);\n      return acc;\n    }, {});\n    const resource_season = this.data.seasons().reduce((acc, cur) => {\n      if (cur.wday === wday) {\n        if (!(cur.resource_id in acc)) acc[cur.resource_id] = [];\n        acc[cur.resource_id].push([timeToNumber(cur.from_time), timeToNumber(cur.to_time)]);\n      }\n      return acc;\n    }, {});\n    const available_ids = Object.keys(resource_season).filter(id => {\n      if (!(id in resource_allocation)) return true;\n      return !allocationFillsAllowed(resource_allocation[id], resource_season[id]);\n    }).map(id => +id);\n    this.data.resources_with_available_time([...new Set([...available_ids, ...this.easy_booking_available_cache[this.data.date()]])]);\n    // console.log(\"Available ids\", available_ids);\n  };\n  updateBuildings = (town = null) => {\n    this.data.buildings(this.data.towns_data().filter(item => town ? town.id === item.id : true).map(item => ({\n      id: item.b_id,\n      name: htmlDecode(item.b_name)\n    })).sort((a, b) => a.name?.localeCompare(b.name, \"no\")));\n  };\n  getResourcesFromBuildings = buildings => {\n    const building_ids = buildings.map(building => building.id);\n    return this.data.building_resources().filter(resource => building_ids.includes(resource.building_id)).map(resource => this.data.resources().find(res => res.id === resource.resource_id)).filter(r => !!r);\n  };\n  getBuildingsFromResource = resource_id => {\n    const building_resources = this.data.building_resources().filter(br => br.resource_id === resource_id);\n    const ids = building_resources.map(br => br.building_id);\n    return this.data.buildings().filter(b => ids.includes(b.id));\n  };\n  getTownFromBuilding = buildings => {\n    const ids = buildings.map(b => +b.id);\n    return this.data.towns_data().filter(t => ids.includes(+t.b_id));\n  };\n  cleanTownName = townName => {\n    return townName.split('\\n').map(line => {\n      // Check if 'Bydel' is in the line\n      if (line.toLowerCase().includes('bydel')) {\n        // Remove 'Bydel'\n        line = line.replace(/bydel/gi, '').trim();\n      }\n      // Capitalize first letter of each word\n      return line.charAt(0).toUpperCase() + line.slice(1).toLowerCase();\n    }).join('\\n');\n  };\n  addInfoCards(el, resources) {\n    const append = [];\n    const okResources = [];\n    // const calendars = [];\n    for (const resource of resources) {\n      const buildings = this.getBuildingsFromResource(resource.id);\n      const towns = this.getTownFromBuilding(buildings);\n      if (towns.length > 0) {\n        const calendarId = `calendar-${resource.id}`;\n        okResources.push(resource);\n        let url = \"\";\n        if (resource.simple_booking === 1) {\n          url = phpGWLink('bookingfrontend/', {\n            menuaction: 'bookingfrontend.uiresource.show',\n            building_id: buildings[0].id,\n            id: resource.id\n          }, false);\n        } else {\n          url = phpGWLink('bookingfrontend/', {\n            menuaction: 'bookingfrontend.uiapplication.add',\n            building_id: buildings[0].id,\n            resource_id: resource.id\n          }, false);\n        }\n        const locationUrl = phpGWLink('bookingfrontend/', {\n          menuaction: 'bookingfrontend.uibuilding.show',\n          id: buildings[0].id\n        });\n        // language=HTML\n        append.push(`\n                            <div class=\"col-12 mb-4\">\n                                <div class=\"js-slidedown slidedown\">\n                                    <button class=\"js-slidedown-toggler slidedown__toggler\" type=\"button\" aria-expanded=\"false\">\n                                        <span><div class=\"fa-solid fa-layer-group\"></div> ${resource.name}</span>\n                                        <span class=\"slidedown__toggler__info\">\n                ${joinWithDot([`<span class=\"text-primary\">Bydel:</span> ${joinWithDot(towns.map(t => this.cleanTownName(t.name)))}`, ...buildings.map(b => {\n          const buildingUrl = phpGWLink('bookingfrontend/', {\n            menuaction: 'bookingfrontend.uibuilding.show',\n            id: b.id\n          });\n          return `<a href=\"${buildingUrl}\" class=\"link-text link-text-secondary\"><i class=\"fa-solid fa-location-dot\"></i>${b.name}<i class=\"fa-solid fa-arrow-right\"></i></a>`;\n        })])}\n            </span>\n                                    </button>\n                                    <div class=\"js-slidedown-content slidedown__content\">\n                                        <div>\n<!--                                            <div class=\"d-flex\">-->\n                                                    <!--<button class=\"pe-btn pe-btn-primary\" style=\"margin-right: 8px;\" onclick=\"location.href=\\'${url}\n                                                    \\'\">Søknad</button>-->\n                                                    <!--<button class=\"pe-btn pe-btn-secondary\"\n                                                        onclick=\"location.href=\\'${locationUrl}\\'\">${buildings[0].name}\n                                                </button>-->\n<!--                                            </div>-->\n                                            <p>\n                                                ${resource.description}\n                                            </p>\n                                        </div>\n                                        <div id=\"${calendarId}\" class=\"calendar\" data-building-id=\"${buildings[0].id}\"\n                                             data-resource-id=\"${resource.id}\"\n                                             data-date=\"${getDateFromSearch(this.data.date())}\"></div>\n                                    </div>\n                                </div>\n                            </div>\n                    `);\n      }\n    }\n    this.data.result(okResources.slice(0, 50));\n    el.append(append.join(\"\"));\n    el.find('a.link-text').on('click', function (event) {\n      event.stopPropagation();\n      // If you need to follow the link, uncomment the following line\n      // window.location.href = $(this).attr('href');\n    });\n    fillSearchCount(okResources.slice(0, 50), okResources.length);\n    // calendars.map(calendar => calendar.createCalendarDom())\n  }\n  adjustMobilePositionOnSearch() {\n    let searchBox = document.getElementById(\"search-booking\");\n    setTimeout(function () {\n      // Scroll the search box to the top of the screen\n      window.scrollTo(0, searchBox.getBoundingClientRect().top);\n    }, 200);\n  }\n}\nclass EventSearch {\n  data = {\n    text: ko.observable(\"\"),\n    from_date: ko.observable(getSearchDateString(new Date())),\n    to_date: ko.observable(getSearchDateString(new Date(new Date().getTime() + 7 * 86400 * 1000))),\n    events: ko.observableArray([])\n  };\n  constructor() {\n    const eventEl = document.getElementById(\"search-event\");\n    ko.cleanNode(eventEl);\n    ko.applyBindings(this.data, eventEl);\n    this.data.text.subscribe(text => {\n      this.search();\n    });\n    this.data.from_date.subscribe(from => {\n      this.fetchEventOnDates();\n    });\n    this.data.to_date.subscribe(to => {\n      this.fetchEventOnDates();\n    });\n  }\n  fetchEventOnDates() {\n    const from = this.data.from_date()?.split(\".\");\n    const to = this.data.to_date()?.split(\".\");\n    const fromDate = from && from.length > 1 ? `${from[2]}-${from[1]}-${from[0]}T00:00:00` : getIsoDateString(new Date()); // year-month-day\n    const toDate = to && to.length > 1 ? `${to[2]}-${to[1]}-${to[0]}T23:59:59` : `${from[2]}-${from[1]}-${from[0]}T23:59:59`;\n    const buildingID = \"\";\n    const facilityTypeID = \"\";\n    const start = 0;\n    const end = 1000;\n    const loggedInOrgs = \"\";\n    const url = phpGWLink('bookingfrontend/', {\n      menuaction: 'bookingfrontend.uieventsearch.upcoming_events',\n      fromDate,\n      toDate,\n      buildingID,\n      facilityTypeID,\n      loggedInOrgs,\n      start,\n      end,\n      length: -1\n    }, true);\n    $.ajax({\n      url,\n      success: response => {\n        this.data.events = response;\n        this.search();\n      },\n      error: error => {\n        console.log(error);\n      }\n    });\n  }\n  reset() {\n    this.data.text(\"\");\n    this.data.from_date(getSearchDateString(new Date()));\n    this.data.to_date(\"\");\n  }\n  search() {\n    let events = this.data.events.slice(0, 5);\n    let count = this.data.events.length;\n    const el = emptySearch();\n    if (this.data.text() !== \"\") {\n      const re = new RegExp(this.data.text(), 'i');\n      events = this.data.events.filter(o => o.event_name.match(re) || o.location_name.match(re));\n      count = events.length;\n    }\n    this.addInfoCards(el, events, count);\n    createJsSlidedowns();\n  }\n  addInfoCards(el, events, count) {\n    const append = [];\n    for (const event of events) {\n      append.push(`\n    <div class=\"col-12 mb-4\">\n      <div class=\"js-slidedown slidedown\">\n        <button class=\"js-slidedown-toggler slidedown__toggler\" type=\"button\" aria-expanded=\"false\">\n          <span>${event.event_name}</span>\n          <span class=\"slidedown__toggler__info\">\n          ${joinWithDot([event.location_name, getSearchDatetimeString(new Date(event.from)) + \" - \" + (new Date(event.from).getDate() === new Date(event.to).getDate() ? getSearchTimeString(new Date(event.to)) : getSearchDatetimeString(new Date(event.to)))])}\n          </span>\n        </button>\n        <div class=\"js-slidedown-content slidedown__content\">\n          <p>\n            ${event.location_name}\n            <ul>\n                <li>Fra: ${event.from}</li>\n                <li>Til: ${event.to}</li>\n            </ul>\n          </p> \n        </div>\n      </div>\n    </div>\n`);\n    }\n    el.append(append.join(\"\"));\n    fillSearchCount(events, count);\n  }\n}\nclass Search {\n  // All data from server\n  data = {\n    location: [],\n    activities: [],\n    resource_categories: [],\n    resources: [],\n    facilities: [],\n    buildings: [],\n    building_resources: [],\n    organizations: [],\n    events: []\n  };\n  booking = new BookingSearch();\n  event = new EventSearch();\n  organization = new OrganizationSearch();\n  ko_search = {\n    type_group: ko.observable(null),\n    header_text: ko.observable(\"\"),\n    header_sub: ko.observable(\"\")\n  };\n  constructor() {\n    const searchEl = document.getElementById(\"search-header\");\n    ko.cleanNode(searchEl);\n    ko.applyBindings(this.ko_search, searchEl);\n    this.ko_search.type_group.subscribe(type => {\n      this.updateHeaderTexts(type);\n    });\n    this.fetchData();\n    const self = this;\n    $(document).ready(function () {\n      self.ko_search.type_group(location.hash.substring(1));\n    });\n    $('#id-reset-filter').click(() => {\n      switch (self.ko_search.type_group()) {\n        case \"booking\":\n          self.booking.reset();\n          break;\n        case \"event\":\n          self.event.reset();\n          break;\n        case \"organization\":\n          self.organization.reset();\n          break;\n        default:\n      }\n    });\n  }\n  fetchData = () => {\n    const self = this;\n    const url = phpGWLink('bookingfrontend/', {\n      menuaction: 'bookingfrontend.uisearch.get_search_data_all',\n      length: -1\n    }, true);\n    $.ajax({\n      url,\n      success: response => {\n        // console.log(response);\n        self.data = {\n          ...self.data,\n          ...response\n        };\n        self.booking.data.building_resources(response.building_resources);\n        self.booking.data.towns_data(sortOnName(response.towns));\n        self.booking.data.activities(sortOnName(self.data.activities));\n        self.booking.data.resources(sortOnName(self.data.resources.map(resource => ({\n          ...resource,\n          name: htmlDecode(resource.name)\n        }))));\n        self.booking.data.facilities(sortOnName(self.data.facilities.map(facility => ({\n          ...facility,\n          name: htmlDecode(facility.name)\n        }))));\n        self.booking.data.resource_categories(sortOnName(self.data.resource_categories));\n        self.booking.data.resource_facilities(self.data.resource_facilities);\n        self.booking.data.resource_activities(self.data.resource_activities);\n        self.booking.data.resource_category_activity(self.data.resource_category_activity);\n        self.event.data.events(self.data.events);\n        self.organization.data.activities(sortOnName(self.data.activities.map(activity => ({\n          ...activity,\n          name: htmlDecode(activity.name)\n        }))));\n        self.organization.data.organizations(self.data.organizations.map(organization => ({\n          ...organization,\n          name: htmlDecode(organization.name)\n        })));\n      },\n      error: error => {\n        console.log(error);\n      }\n    });\n  };\n  updateHeaderTexts = type => {\n    switch (type) {\n      case \"booking\":\n        if (!landing_sections.booking) {\n          this.updateHeaderTexts();\n          break;\n        }\n        this.ko_search.header_text(\"Lei lokale, anlegg eller utstyr\");\n        this.ko_search.header_sub(\"Bruk filtrene til å finne de leieobjekter som du ønsker å leie\");\n        $(\"#search-booking\").show();\n        $(\"#search-event\").hide();\n        $(\"#search-organization\").hide();\n        this.booking.search();\n        window.location.hash = '#booking';\n        break;\n      case \"event\":\n        if (!landing_sections.event) {\n          this.updateHeaderTexts();\n          break;\n        }\n        this.ko_search.header_text(\"Finn arrangement eller aktivitet\");\n        this.ko_search.header_sub(\"Bruk filtrene til å finne ut hva som skjer i dag, eller til helgen\");\n        $(\"#search-event\").show();\n        $(\"#search-booking\").hide();\n        $(\"#search-organization\").hide();\n        if (this.data.events.length === 0) {\n          this.event.fetchEventOnDates();\n        }\n        this.event.search();\n        window.location.hash = '#event';\n        break;\n      case \"organization\":\n        if (!landing_sections.organization) {\n          this.updateHeaderTexts();\n          break;\n        }\n        this.ko_search.header_text(\"Finn lag eller organisasjon\");\n        this.ko_search.header_sub(\"Er du på jakt etter noen som er interessert i det samme som deg? Søk på navn til lag eller organisasjon, eller filtrer på aktivitet eller område\");\n        $(\"#search-organization\").show();\n        $(\"#search-booking\").hide();\n        $(\"#search-event\").hide();\n        this.organization.search();\n        window.location.hash = '#organization';\n        break;\n      default:\n        if (landing_sections.booking) {\n          this.ko_search.type_group(\"booking\");\n          break;\n        }\n        if (landing_sections.event) {\n          this.ko_search.type_group(\"event\");\n          break;\n        }\n        this.ko_search.type_group(\"organization\");\n    }\n  };\n}\nconst search = new Search();\nfunction getSearchDateString(date) {\n  return `${date.getDate()}.${date.getMonth() + 1}.${date.getFullYear()}`;\n}\nfunction getSearchTimeString(date) {\n  return `${(\"0\" + date.getHours()).slice(-2)}:${(\"0\" + date.getMinutes()).slice(-2)}`;\n}\nfunction getFullTimeString(date) {\n  return `${(\"0\" + date.getHours()).slice(-2)}:${(\"0\" + date.getMinutes()).slice(-2)}:${(\"0\" + date.getSeconds()).slice(-2)}`;\n}\nfunction getSearchDatetimeString(date) {\n  return `${getSearchDateString(date)} ${getSearchTimeString(date)}`;\n}\nfunction getIsoDateString(date) {\n  return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;\n}\nfunction getDateFromSearch(dateString) {\n  // Normalize the divider to a hyphen\n  const normalizedDateStr = dateString.replace(/[.\\/]/g, '-');\n\n  // Split the date into its components\n  const [day, month, year] = normalizedDateStr.split('-').map(num => parseInt(num, 10));\n\n  // Create a DateTime object\n  const dt = luxon.DateTime.local(year, month, day);\n  return dt.toJSDate();\n}\nfunction getAllSubRowsIds(rows, id) {\n  let result = [id];\n  rows.filter(a => a.parent_id === id).map(a => {\n    result.push(...getAllSubRowsIds(rows, a.id));\n  });\n  return result;\n}\nfunction emptySearch() {\n  const el = $(\"#search-result\");\n  el.empty();\n  return el;\n}\nfunction fillSearchCount(data, count = 0) {\n  const el = $(\"#search-count\");\n  el.empty();\n  if (data) {\n    el.append(`Antall treff: ${data.length}${count > 0 ? \" av \" + count : \"\"}`);\n  }\n}\nfunction htmlDecode(input) {\n  const doc = new DOMParser().parseFromString(input, \"text/html\");\n  const newInput = doc.documentElement.textContent;\n  // Some texts are double encoded\n  const newDoc = new DOMParser().parseFromString(newInput, \"text/html\");\n  return newDoc.documentElement.textContent;\n}\nfunction joinWithDot(texts) {\n  return texts.map(t => t && t.length > 0 ? `<span>${t}</span>` : null).filter(t => t).join(`<span class=\"slidedown__toggler__info__separator\"><i class=\"fa-solid fa-circle\"></i></span>`);\n}\nfunction sortOnField(data, field) {\n  return data.sort((a, b) => a[field]?.localeCompare(b[field], \"no\"));\n}\nfunction sortOnName(data) {\n  return sortOnField(data, 'name');\n}\nfunction arraysAreEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//# sourceURL=webpack://bookingfrontend_2/./src/pages/search.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/pages/search.js");
/******/ 	
/******/ })()
;